/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AddressValidationResults,
  AddressValidationResults$inboundSchema,
} from "./addressvalidationresults.js";

/**
 * Latitude of address
 */
export type Latitude = number | string;

/**
 * Longitude of address
 */
export type Longitude = number | string;

/**
 * Address represents the address as retrieved from the database
 */
export type Address = {
  /**
   * **required for purchase**<br>
   *
   * @remarks
   * First and Last Name of the addressee
   */
  name?: string | undefined;
  /**
   * Company Name
   */
  company?: string | undefined;
  /**
   * **required for purchase**<br>
   *
   * @remarks
   * First street line. Usually street number and street name (except for DHL Germany, see street_no).
   */
  street1?: string | undefined;
  /**
   * Second street line.
   */
  street2?: string | undefined;
  /**
   * Third street line.
   *
   * @remarks
   * Only accepted for USPS international shipments, UPS domestic and UPS international shipments.
   */
  street3?: string | undefined;
  /**
   * Street number of the addressed building.
   *
   * @remarks
   * This field can be included in street1 for all carriers except for DHL Germany.
   */
  streetNo?: string | undefined;
  /**
   * **required for purchase**<br>
   *
   * @remarks
   * Name of a city. When creating a Quote Address, sending a city is optional but will yield more accurate Rates.
   * Please bear in mind that city names may be ambiguous (there are 34 Springfields in the US). Pass in a state
   * or a ZIP code (see below), if known, it will yield more accurate results.
   */
  city?: string | undefined;
  /**
   * **required for purchase for some countries**<br>
   *
   * @remarks
   * State/Province values are required for shipments from/to the US, AU, and CA. UPS requires province for some
   * countries (i.e Ireland). To receive more accurate quotes, passing this field is recommended. Most carriers
   * only accept two or three character state abbreviations.
   */
  state?: string | undefined;
  /**
   * **required for purchase**<br>
   *
   * @remarks
   * Postal code of an Address. When creating a Quote Addresses, sending a ZIP is optional but will yield more
   * accurate Rates.
   */
  zip?: string | undefined;
  /**
   * ISO 3166-1 alpha-2 country codes and country names can be used. For most consistent results, we recommend using country codes like `US` or `DE`.
   *
   * @remarks
   * If using country names, please ensure they are spelled correctly and in English. Country names are converted to country codes.
   * Refer to this <a href="https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements" target="_blank">guide</a> for a list of country codes.
   * Sending a country is always required.
   */
  country: string;
  /**
   * Addresses containing a phone number allow carriers to call the recipient when delivering the Parcel. This
   *
   * @remarks
   * increases the probability of delivery and helps to avoid accessorial charges after a Parcel has been shipped.
   */
  phone?: string | undefined;
  /**
   * E-mail address of the contact person, RFC3696/5321-compliant.
   */
  email?: string | undefined;
  isResidential?: boolean | undefined;
  /**
   * A string of up to 100 characters that can be filled with any additional information you want
   *
   * @remarks
   * to attach to the object.
   */
  metadata?: string | undefined;
  /**
   * Complete addresses contain all required values.<br><br>Incomplete addresses have failed one or multiple
   *
   * @remarks
   * validations.<br>Incomplete Addresses are eligible for requesting rates but lack at least one required
   * value for purchasing labels.
   */
  isComplete?: boolean | undefined;
  /**
   * Latitude of address
   */
  latitude?: number | string | undefined;
  /**
   * Longitude of address
   */
  longitude?: number | string | undefined;
  /**
   * Date and time of Address creation.
   */
  objectCreated?: Date | undefined;
  /**
   * Unique identifier of the given Address object.
   *
   * @remarks
   * This ID is required to create a Shipment object.
   */
  objectId?: string | undefined;
  /**
   * Username of the user who created the Address object.
   */
  objectOwner?: string | undefined;
  /**
   * Date and time of last Address update. Since you cannot update Addresses after they were created, this time
   *
   * @remarks
   * stamp reflects the time when the Address was changed by Shippo's systems for the last time, e.g., during the
   * approximation of one or more values.
   */
  objectUpdated?: Date | undefined;
  /**
   * Object that contains information regarding if an address had been validated or not. Also contains any messages
   *
   * @remarks
   * generated during validation. Children keys are <code>is_valid</code>(boolean) and <code>messages</code>(array).
   */
  validationResults?: AddressValidationResults | undefined;
  /**
   * Indicates whether the object has been created in test mode.
   */
  test?: boolean | undefined;
};

/** @internal */
export const Latitude$inboundSchema: z.ZodMiniType<Latitude, unknown> = z.union(
  [z.number(), z.string()],
);

export function latitudeFromJSON(
  jsonString: string,
): SafeParseResult<Latitude, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Latitude$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Latitude' from JSON`,
  );
}

/** @internal */
export const Longitude$inboundSchema: z.ZodMiniType<Longitude, unknown> = z
  .union([z.number(), z.string()]);

export function longitudeFromJSON(
  jsonString: string,
): SafeParseResult<Longitude, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Longitude$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Longitude' from JSON`,
  );
}

/** @internal */
export const Address$inboundSchema: z.ZodMiniType<Address, unknown> = z.pipe(
  z.object({
    name: z.optional(z.string()),
    company: z.optional(z.string()),
    street1: z.optional(z.string()),
    street2: z.optional(z.string()),
    street3: z.optional(z.string()),
    street_no: z.optional(z.string()),
    city: z.optional(z.string()),
    state: z.optional(z.string()),
    zip: z.optional(z.string()),
    country: z.string(),
    phone: z.optional(z.string()),
    email: z.optional(z.string()),
    is_residential: z.optional(z.boolean()),
    metadata: z.optional(z.string()),
    is_complete: z.optional(z.boolean()),
    latitude: z.optional(z.union([z.number(), z.string()])),
    longitude: z.optional(z.union([z.number(), z.string()])),
    object_created: z.optional(
      z.pipe(z.iso.datetime({ offset: true }), z.transform(v => new Date(v))),
    ),
    object_id: z.optional(z.string()),
    object_owner: z.optional(z.string()),
    object_updated: z.optional(
      z.pipe(z.iso.datetime({ offset: true }), z.transform(v => new Date(v))),
    ),
    validation_results: z.optional(AddressValidationResults$inboundSchema),
    test: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "street_no": "streetNo",
      "is_residential": "isResidential",
      "is_complete": "isComplete",
      "object_created": "objectCreated",
      "object_id": "objectId",
      "object_owner": "objectOwner",
      "object_updated": "objectUpdated",
      "validation_results": "validationResults",
    });
  }),
);

export function addressFromJSON(
  jsonString: string,
): SafeParseResult<Address, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Address$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Address' from JSON`,
  );
}
