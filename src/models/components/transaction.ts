/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  CoreRate,
  CoreRate$inboundSchema,
  CoreRate$Outbound,
  CoreRate$outboundSchema,
} from "./corerate.js";
import {
  LabelFileTypeEnum,
  LabelFileTypeEnum$inboundSchema,
  LabelFileTypeEnum$outboundSchema,
} from "./labelfiletypeenum.js";
import {
  ObjectStateEnum,
  ObjectStateEnum$inboundSchema,
  ObjectStateEnum$outboundSchema,
} from "./objectstateenum.js";
import {
  ResponseMessage,
  ResponseMessage$inboundSchema,
  ResponseMessage$Outbound,
  ResponseMessage$outboundSchema,
} from "./responsemessage.js";
import {
  TrackingStatusEnum,
  TrackingStatusEnum$inboundSchema,
  TrackingStatusEnum$outboundSchema,
} from "./trackingstatusenum.js";
import {
  TransactionStatusEnum,
  TransactionStatusEnum$inboundSchema,
  TransactionStatusEnum$outboundSchema,
} from "./transactionstatusenum.js";

/**
 * An object with details about the user who created the Transaction (purchased the label).
 *
 * @remarks
 * A value will be returned only for Transactions that can be associated with a specific user, e.g. when a logged-in
 * user purchases a label via the Shippo Web application; but not for Transactions purchased e.g. via the API using a ShippoToken,
 * which is associated with the account but not any specific user.
 */
export type CreatedBy = {
  firstName?: string | undefined;
  lastName?: string | undefined;
  username?: string | undefined;
};

/**
 * ID of the Rate object for which a Label has to be obtained.
 *
 * @remarks
 * If you purchase a label by calling the transaction endpoint without a rate (instalabel),
 * this field will be a simplified Rate object in the Transaction model returned from the POST request.
 * </br>Note, only rates less than 7 days old can be purchased to ensure up-to-date pricing.
 */
export type TransactionRate = CoreRate | string;

export type Transaction = {
  /**
   * A URL pointing to the commercial invoice as a 8.5x11 inch PDF file.
   *
   * @remarks
   * A value will only be returned if the Transactions has been processed successfully and if the shipment is international.
   */
  commercialInvoiceUrl?: string | undefined;
  createdBy?: CreatedBy | null | undefined;
  /**
   * The estimated time of arrival according to the carrier.
   */
  eta?: string | undefined;
  /**
   * Print format of the <a href="https://docs.goshippo.com/docs/shipments/shippinglabelsizes/">label</a>. If empty, will use the default format set from
   *
   * @remarks
   * <a href="https://apps.goshippo.com/settings/labels">the Shippo dashboard.</a>
   */
  labelFileType?: LabelFileTypeEnum | undefined;
  /**
   * A URL pointing directly to the label in the format you've set in your settings.
   *
   * @remarks
   * A value will only be returned if the Transactions has been processed successfully.
   */
  labelUrl?: string | undefined;
  messages?: Array<ResponseMessage> | undefined;
  /**
   * A string of up to 100 characters that can be filled with any additional information you want to
   *
   * @remarks
   * attach to the object.
   */
  metadata?: string | undefined;
  /**
   * Date and time of Transaction creation.
   */
  objectCreated?: Date | undefined;
  /**
   * Unique identifier of the given Transaction object.
   */
  objectId?: string | undefined;
  /**
   * Username of the user who created the Transaction object.
   */
  objectOwner?: string | undefined;
  /**
   * Indicates the validity of the enclosing object
   */
  objectState?: ObjectStateEnum | undefined;
  /**
   * Date and time of last Transaction update.
   */
  objectUpdated?: Date | undefined;
  /**
   * Object ID of the Parcel object that is being shipped.
   */
  parcel?: string | undefined;
  /**
   * A URL pointing directly to the QR code in PNG format.
   *
   * @remarks
   * A value will only be returned if requested using qr_code_requested flag and the carrier provides such an option.
   */
  qrCodeUrl?: string | undefined;
  /**
   * ID of the Rate object for which a Label has to be obtained.
   *
   * @remarks
   * If you purchase a label by calling the transaction endpoint without a rate (instalabel),
   * this field will be a simplified Rate object in the Transaction model returned from the POST request.
   * </br>Note, only rates less than 7 days old can be purchased to ensure up-to-date pricing.
   */
  rate?: CoreRate | string | undefined;
  /**
   * Indicates the status of the Transaction.
   */
  status?: TransactionStatusEnum | undefined;
  /**
   * Indicates whether the object has been created in test mode.
   */
  test?: boolean | undefined;
  /**
   * The carrier-specific tracking number that can be used to track the Shipment.
   *
   * @remarks
   * A value will only be returned if the Rate is for a trackable Shipment and if the Transactions has been processed successfully.
   */
  trackingNumber?: string | undefined;
  /**
   * Indicates the high level status of the shipment.
   */
  trackingStatus?: TrackingStatusEnum | undefined;
  /**
   * A link to track this item on the carrier-provided tracking website.
   *
   * @remarks
   * A value will only be returned if tracking is available and the carrier provides such a service.
   */
  trackingUrlProvider?: string | undefined;
};

/** @internal */
export const CreatedBy$inboundSchema: z.ZodMiniType<CreatedBy, unknown> = z
  .pipe(
    z.object({
      first_name: z.optional(z.string()),
      last_name: z.optional(z.string()),
      username: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "first_name": "firstName",
        "last_name": "lastName",
      });
    }),
  );
/** @internal */
export type CreatedBy$Outbound = {
  first_name?: string | undefined;
  last_name?: string | undefined;
  username?: string | undefined;
};

/** @internal */
export const CreatedBy$outboundSchema: z.ZodMiniType<
  CreatedBy$Outbound,
  CreatedBy
> = z.pipe(
  z.object({
    firstName: z.optional(z.string()),
    lastName: z.optional(z.string()),
    username: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      firstName: "first_name",
      lastName: "last_name",
    });
  }),
);

export function createdByToJSON(createdBy: CreatedBy): string {
  return JSON.stringify(CreatedBy$outboundSchema.parse(createdBy));
}
export function createdByFromJSON(
  jsonString: string,
): SafeParseResult<CreatedBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatedBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatedBy' from JSON`,
  );
}

/** @internal */
export const TransactionRate$inboundSchema: z.ZodMiniType<
  TransactionRate,
  unknown
> = z.union([CoreRate$inboundSchema, z.string()]);
/** @internal */
export type TransactionRate$Outbound = CoreRate$Outbound | string;

/** @internal */
export const TransactionRate$outboundSchema: z.ZodMiniType<
  TransactionRate$Outbound,
  TransactionRate
> = z.union([CoreRate$outboundSchema, z.string()]);

export function transactionRateToJSON(
  transactionRate: TransactionRate,
): string {
  return JSON.stringify(TransactionRate$outboundSchema.parse(transactionRate));
}
export function transactionRateFromJSON(
  jsonString: string,
): SafeParseResult<TransactionRate, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TransactionRate$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TransactionRate' from JSON`,
  );
}

/** @internal */
export const Transaction$inboundSchema: z.ZodMiniType<Transaction, unknown> = z
  .pipe(
    z.object({
      commercial_invoice_url: z.optional(z.string()),
      created_by: z.optional(z.nullable(z.lazy(() => CreatedBy$inboundSchema))),
      eta: z.optional(z.string()),
      label_file_type: z.optional(LabelFileTypeEnum$inboundSchema),
      label_url: z.optional(z.string()),
      messages: z.optional(z.array(ResponseMessage$inboundSchema)),
      metadata: z.optional(z.string()),
      object_created: z.optional(
        z.pipe(z.iso.datetime({ offset: true }), z.transform(v => new Date(v))),
      ),
      object_id: z.optional(z.string()),
      object_owner: z.optional(z.string()),
      object_state: z.optional(ObjectStateEnum$inboundSchema),
      object_updated: z.optional(
        z.pipe(z.iso.datetime({ offset: true }), z.transform(v => new Date(v))),
      ),
      parcel: z.optional(z.string()),
      qr_code_url: z.optional(z.string()),
      rate: z.optional(z.union([CoreRate$inboundSchema, z.string()])),
      status: z.optional(TransactionStatusEnum$inboundSchema),
      test: z.optional(z.boolean()),
      tracking_number: z.optional(z.string()),
      tracking_status: z.optional(TrackingStatusEnum$inboundSchema),
      tracking_url_provider: z.optional(z.string()),
    }),
    z.transform((v) => {
      return remap$(v, {
        "commercial_invoice_url": "commercialInvoiceUrl",
        "created_by": "createdBy",
        "label_file_type": "labelFileType",
        "label_url": "labelUrl",
        "object_created": "objectCreated",
        "object_id": "objectId",
        "object_owner": "objectOwner",
        "object_state": "objectState",
        "object_updated": "objectUpdated",
        "qr_code_url": "qrCodeUrl",
        "tracking_number": "trackingNumber",
        "tracking_status": "trackingStatus",
        "tracking_url_provider": "trackingUrlProvider",
      });
    }),
  );
/** @internal */
export type Transaction$Outbound = {
  commercial_invoice_url?: string | undefined;
  created_by?: CreatedBy$Outbound | null | undefined;
  eta?: string | undefined;
  label_file_type?: string | undefined;
  label_url?: string | undefined;
  messages?: Array<ResponseMessage$Outbound> | undefined;
  metadata?: string | undefined;
  object_created?: string | undefined;
  object_id?: string | undefined;
  object_owner?: string | undefined;
  object_state?: string | undefined;
  object_updated?: string | undefined;
  parcel?: string | undefined;
  qr_code_url?: string | undefined;
  rate?: CoreRate$Outbound | string | undefined;
  status?: string | undefined;
  test?: boolean | undefined;
  tracking_number?: string | undefined;
  tracking_status?: string | undefined;
  tracking_url_provider?: string | undefined;
};

/** @internal */
export const Transaction$outboundSchema: z.ZodMiniType<
  Transaction$Outbound,
  Transaction
> = z.pipe(
  z.object({
    commercialInvoiceUrl: z.optional(z.string()),
    createdBy: z.optional(z.nullable(z.lazy(() => CreatedBy$outboundSchema))),
    eta: z.optional(z.string()),
    labelFileType: z.optional(LabelFileTypeEnum$outboundSchema),
    labelUrl: z.optional(z.string()),
    messages: z.optional(z.array(ResponseMessage$outboundSchema)),
    metadata: z.optional(z.string()),
    objectCreated: z.optional(
      z.pipe(z.date(), z.transform(v => v.toISOString())),
    ),
    objectId: z.optional(z.string()),
    objectOwner: z.optional(z.string()),
    objectState: z.optional(ObjectStateEnum$outboundSchema),
    objectUpdated: z.optional(
      z.pipe(z.date(), z.transform(v => v.toISOString())),
    ),
    parcel: z.optional(z.string()),
    qrCodeUrl: z.optional(z.string()),
    rate: z.optional(z.union([CoreRate$outboundSchema, z.string()])),
    status: z.optional(TransactionStatusEnum$outboundSchema),
    test: z.optional(z.boolean()),
    trackingNumber: z.optional(z.string()),
    trackingStatus: z.optional(TrackingStatusEnum$outboundSchema),
    trackingUrlProvider: z.optional(z.string()),
  }),
  z.transform((v) => {
    return remap$(v, {
      commercialInvoiceUrl: "commercial_invoice_url",
      createdBy: "created_by",
      labelFileType: "label_file_type",
      labelUrl: "label_url",
      objectCreated: "object_created",
      objectId: "object_id",
      objectOwner: "object_owner",
      objectState: "object_state",
      objectUpdated: "object_updated",
      qrCodeUrl: "qr_code_url",
      trackingNumber: "tracking_number",
      trackingStatus: "tracking_status",
      trackingUrlProvider: "tracking_url_provider",
    });
  }),
);

export function transactionToJSON(transaction: Transaction): string {
  return JSON.stringify(Transaction$outboundSchema.parse(transaction));
}
export function transactionFromJSON(
  jsonString: string,
): SafeParseResult<Transaction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transaction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transaction' from JSON`,
  );
}
