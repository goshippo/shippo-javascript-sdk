/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Address, Address$inboundSchema } from "./address.js";
import {
  CustomsDeclaration,
  CustomsDeclaration$inboundSchema,
} from "./customsdeclaration.js";
import { Parcel, Parcel$inboundSchema } from "./parcel.js";
import { Rate, Rate$inboundSchema } from "./rate.js";
import {
  ResponseMessage,
  ResponseMessage$inboundSchema,
} from "./responsemessage.js";
import { ShipmentExtra, ShipmentExtra$inboundSchema } from "./shipmentextra.js";

/**
 * `Waiting` shipments have been successfully submitted but not yet been processed.
 *
 * @remarks
 * `Queued` shipments are currently being processed.
 * `Success` shipments have been processed successfully, meaning that rate generation has concluded.
 * `Error` does not occur currently and is reserved for future use.
 */
export const ShipmentStatus = {
  Error: "ERROR",
  Queued: "QUEUED",
  Success: "SUCCESS",
  Waiting: "WAITING",
} as const;
/**
 * `Waiting` shipments have been successfully submitted but not yet been processed.
 *
 * @remarks
 * `Queued` shipments are currently being processed.
 * `Success` shipments have been processed successfully, meaning that rate generation has concluded.
 * `Error` does not occur currently and is reserved for future use.
 */
export type ShipmentStatus = ClosedEnum<typeof ShipmentStatus>;

/**
 * Shipment represents the parcel as retrieved from the database
 */
export type Shipment = {
  /**
   * An object holding optional extra services to be requested.
   */
  extra?: ShipmentExtra | undefined;
  /**
   * A string of up to 100 characters that can be filled with any additional information you want to attach to the object.
   */
  metadata: string;
  /**
   * Date the shipment will be tendered to the carrier. Must be in the format `2014-01-18T00:35:03.463Z`.
   *
   * @remarks
   * Defaults to current date and time if no value is provided. Please note that some carriers require this value to
   * be in the future, on a working day, or similar.
   */
  shipmentDate?: string | undefined;
  /**
   * <a href="#tag/Addresses">Address</a> object of the sender / seller. Will be returned expanded by default.
   */
  addressFrom: Address;
  /**
   * ID of the Address object where the shipment will be sent back to if it is not delivered
   *
   * @remarks
   * (Only available for UPS, USPS, and Fedex shipments). <br/>
   * If this field is not set, your shipments will be returned to the address_from.
   */
  addressReturn?: Address | undefined;
  /**
   * <a href="#tag/Addresses">Address</a> object of the recipient / buyer. Will be returned expanded by default.
   */
  addressTo: Address;
  /**
   * An array of object_ids of the carrier account objects to be used for getting shipping rates for this shipment.
   *
   * @remarks
   * If no carrier account object_ids are set in this field, Shippo will attempt to generate rates using all the
   * carrier accounts that have the `active` field set.
   */
  carrierAccounts: Array<string>;
  customsDeclaration?: CustomsDeclaration | undefined;
  messages: Array<ResponseMessage>;
  /**
   * Date and time of Shipment creation.
   */
  objectCreated: Date;
  /**
   * Unique identifier of the given Shipment object.
   */
  objectId: string;
  /**
   * Username of the user who created the Shipment object.
   */
  objectOwner: string;
  /**
   * Date and time of last Shipment update.
   */
  objectUpdated: Date;
  /**
   * List of Parcel objects to be shipped.
   */
  parcels: Array<Parcel>;
  /**
   * An array with all available rates. If <code>async</code> has been set to <code>false</code> in the request,
   *
   * @remarks
   * this will be populated with all available rates in the response. Otherwise rates will be created
   * asynchronously and this array will initially be empty.
   */
  rates: Array<Rate>;
  /**
   * `Waiting` shipments have been successfully submitted but not yet been processed.
   *
   * @remarks
   * `Queued` shipments are currently being processed.
   * `Success` shipments have been processed successfully, meaning that rate generation has concluded.
   * `Error` does not occur currently and is reserved for future use.
   */
  status: ShipmentStatus;
  /**
   * Indicates whether the object has been created in test mode.
   */
  test?: boolean | undefined;
};

/** @internal */
export const ShipmentStatus$inboundSchema: z.ZodMiniEnum<
  typeof ShipmentStatus
> = z.enum(ShipmentStatus);

/** @internal */
export const Shipment$inboundSchema: z.ZodMiniType<Shipment, unknown> = z.pipe(
  z.object({
    extra: z.optional(ShipmentExtra$inboundSchema),
    metadata: z.string(),
    shipment_date: z.optional(z.string()),
    address_from: Address$inboundSchema,
    address_return: z.optional(Address$inboundSchema),
    address_to: Address$inboundSchema,
    carrier_accounts: z.array(z.string()),
    customs_declaration: z.optional(CustomsDeclaration$inboundSchema),
    messages: z.array(ResponseMessage$inboundSchema),
    object_created: z.pipe(
      z.iso.datetime({ offset: true }),
      z.transform(v => new Date(v)),
    ),
    object_id: z.string(),
    object_owner: z.string(),
    object_updated: z.pipe(
      z.iso.datetime({ offset: true }),
      z.transform(v => new Date(v)),
    ),
    parcels: z.array(Parcel$inboundSchema),
    rates: z.array(Rate$inboundSchema),
    status: ShipmentStatus$inboundSchema,
    test: z.optional(z.boolean()),
  }),
  z.transform((v) => {
    return remap$(v, {
      "shipment_date": "shipmentDate",
      "address_from": "addressFrom",
      "address_return": "addressReturn",
      "address_to": "addressTo",
      "carrier_accounts": "carrierAccounts",
      "customs_declaration": "customsDeclaration",
      "object_created": "objectCreated",
      "object_id": "objectId",
      "object_owner": "objectOwner",
      "object_updated": "objectUpdated",
    });
  }),
);

export function shipmentFromJSON(
  jsonString: string,
): SafeParseResult<Shipment, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Shipment$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Shipment' from JSON`,
  );
}
