/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v4-mini";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { Address, Address$inboundSchema } from "./address.js";
import { LineItem, LineItem$inboundSchema } from "./lineitem.js";
import {
  OrderShopAppEnum,
  OrderShopAppEnum$inboundSchema,
} from "./ordershopappenum.js";
import {
  OrderStatusEnum,
  OrderStatusEnum$inboundSchema,
} from "./orderstatusenum.js";
import {
  WeightUnitEnum,
  WeightUnitEnum$inboundSchema,
} from "./weightunitenum.js";

export type Transactions = {};

export type Order = {
  /**
   * **Required if total_price is provided**<br>
   *
   * @remarks
   * Currency of the <code>total_price</code> and <code>total_tax</code> amounts.
   */
  currency?: string | undefined;
  /**
   * Custom buyer- or seller-provided notes about the order.
   */
  notes?: string | undefined;
  /**
   * An alphanumeric identifier for the order used by the seller/buyer. This identifier doesn't need to be unique.
   */
  orderNumber?: string | undefined;
  /**
   * Current state of the order. See the <a href="https://docs.goshippo.com/docs/orders/orders/">orders tutorial</a>
   *
   * @remarks
   * for the logic of how the status is handled.
   */
  orderStatus?: OrderStatusEnum | undefined;
  /**
   * Date and time when the order was placed. This datetime can be different from the datetime of the order object creation on Shippo.
   */
  placedAt: string;
  /**
   * Amount paid by the buyer for shipping. This amount can be different from the price the seller will actually pay for shipping.
   */
  shippingCost?: string | undefined;
  /**
   * **Required if shipping_cost is provided**<br>
   *
   * @remarks
   * Currency of the <code>shipping_cost</code> amount.
   */
  shippingCostCurrency?: string | undefined;
  /**
   * Shipping method (carrier + service or other free text description) chosen by the buyer.
   *
   * @remarks
   * This value can be different from the shipping method the seller will actually choose.
   */
  shippingMethod?: string | undefined;
  subtotalPrice?: string | undefined;
  /**
   * Total amount paid by the buyer for this order.
   */
  totalPrice?: string | undefined;
  /**
   * Total tax amount paid by the buyer for this order.
   */
  totalTax?: string | undefined;
  /**
   * Total weight of the order.
   */
  weight?: string | undefined;
  /**
   * The unit used for weight.
   */
  weightUnit?: WeightUnitEnum | undefined;
  /**
   * <a href="#tag/Addresses">Address</a> object of the sender / seller. Will be returned expanded by default.
   */
  fromAddress?: Address | undefined;
  /**
   * <a href="#tag/Addresses">Address</a> object of the recipient / buyer. Will be returned expanded by default.
   */
  toAddress: Address;
  /**
   * Array of <a href="#section/Line-Item">line item</a> objects representing the items in this order.
   *
   * @remarks
   * All objects will be returned expanded by default.
   */
  lineItems?: Array<LineItem> | undefined;
  /**
   * Unique identifier of the order object.
   */
  objectId?: string | undefined;
  /**
   * Username of the user who created the object.
   */
  objectOwner?: string | undefined;
  /**
   * Platform the order was created on and, if applicable, imported from.
   *
   * @remarks
   * Orders created via the Shippo API or dashboard will have the value "Shippo".
   */
  shopApp?: OrderShopAppEnum | undefined;
  /**
   * Array of <a href="#tag/Transactions">transaction</a> objects representing all shipping labels purchased for this order.
   *
   * @remarks
   * All objects are returned expanded with a limited number of fields by default.
   */
  transactions?: Array<Transactions> | undefined;
};

/** @internal */
export const Transactions$inboundSchema: z.ZodMiniType<Transactions, unknown> =
  z.object({});

export function transactionsFromJSON(
  jsonString: string,
): SafeParseResult<Transactions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Transactions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Transactions' from JSON`,
  );
}

/** @internal */
export const Order$inboundSchema: z.ZodMiniType<Order, unknown> = z.pipe(
  z.object({
    currency: z.optional(z.string()),
    notes: z.optional(z.string()),
    order_number: z.optional(z.string()),
    order_status: z.optional(OrderStatusEnum$inboundSchema),
    placed_at: z.string(),
    shipping_cost: z.optional(z.string()),
    shipping_cost_currency: z.optional(z.string()),
    shipping_method: z.optional(z.string()),
    subtotal_price: z.optional(z.string()),
    total_price: z.optional(z.string()),
    total_tax: z.optional(z.string()),
    weight: z.optional(z.string()),
    weight_unit: z.optional(WeightUnitEnum$inboundSchema),
    from_address: z.optional(Address$inboundSchema),
    to_address: Address$inboundSchema,
    line_items: z.optional(z.array(LineItem$inboundSchema)),
    object_id: z.optional(z.string()),
    object_owner: z.optional(z.string()),
    shop_app: z.optional(OrderShopAppEnum$inboundSchema),
    transactions: z.optional(z.array(z.lazy(() => Transactions$inboundSchema))),
  }),
  z.transform((v) => {
    return remap$(v, {
      "order_number": "orderNumber",
      "order_status": "orderStatus",
      "placed_at": "placedAt",
      "shipping_cost": "shippingCost",
      "shipping_cost_currency": "shippingCostCurrency",
      "shipping_method": "shippingMethod",
      "subtotal_price": "subtotalPrice",
      "total_price": "totalPrice",
      "total_tax": "totalTax",
      "weight_unit": "weightUnit",
      "from_address": "fromAddress",
      "to_address": "toAddress",
      "line_items": "lineItems",
      "object_id": "objectId",
      "object_owner": "objectOwner",
      "shop_app": "shopApp",
    });
  }),
);

export function orderFromJSON(
  jsonString: string,
): SafeParseResult<Order, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Order$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Order' from JSON`,
  );
}
